# leetcode刷题记录
## day1
### 1.两数之和
**题解：** 给定一个数组nums和目标值target，找出和为目标值的两个整数，并返回下标。<br>
·暴力法：双循环，时间复杂度O(n^2)，空间复杂度O(1)。<br>
·两遍哈希表：哈希表保存元素与索引。哈希表将查找时间从O(n)降到O(1)，时间复杂的O(n),空间复杂度O(n)。<br>
·一遍哈希表法：一边遍历一边存入哈希表，时间复杂的O(n),空间复杂度O(n)。<br>
### 15.三数之和
**题解：** 排序，固定一个数字然后头尾双指针。时间复杂度O(n^2)，空间复杂度O(1)。<br>
### 16.最接近的三数之和
**题解：** 排序+双指针
### 18.四数之和
**题解：** 双循环+双指针。--时间还可继续优化。
### 14.最长公共前缀
**题解：** 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。<br>
·依次扫描法：依次遍历字符串，遍历第i个字符串的时候，找到公共前缀，时间复杂的O(s),s是所有字符数量总和,空间复杂度O(1)。<br>
·同时扫描法：水平扫描时遍历所有字符串，如果相同，继续扫描。时间复杂的O(s),s是所有字符数量总和,空间复杂度O(1)。<br>
·分治：将原问题分成两个子问题。时间复杂的O(s),s是所有字符数量总和,空间复杂度O(mlog(n))。<br>
·二分查找法：时间复杂的O(slog(n)),s是所有字符数量总和,空间复杂度O(1)。<br>
### 125.验证回文串
**题解：** 双指针法。设置左右指针，向中间判断，跳过非数字字母的字符；将字母全部装化为小写。<br>
python可使用filter(str.isalnum,s)。<br>
### 151.反转字符串里的单词
**题解：** 倒序遍历字符串，遇到字母记录位置i，继续遍历遇到空格记录j，添加s[j+1:i+1]。由于首部没有空格，可以在字符串前加' '，或者最后加上s[:i+1]。<br>
### 33.搜索旋转排序数组
**题解：** 二分查找法，时间复杂度O(logn)。<br>  
### 153.寻找旋转排序数组中的最小值
**题解：** 二分查找法，时间复杂度O(logn)。<br>
### 859.亲密字符串
**题解：** 对于两个小写字符串A、B,通过交换A中两个字母得到B相等的结果则返回True，否则返回False。首先判断字符串A、B长度是否相等，如果不相等直接返回False。<br>
·A、B如果相等，需要交换两个相同的元素，判断A中是否有相同元素；<br>
·如果不等，且不相等的字符为两个，判断能否交换两个字母使A、B相等，否则返回False。<br>
## day2
### 2.两数相加
**题解：** 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。注意进位。
### 21.合并两个有序列表
**题解：** 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
### 23.合并K个排序链表
**题解：** 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。<br>
解法一：暴力（列表加速）<br>
解法二：逐一比较（用队列优化）<br>
解法三：逐一两两合并<br>
解法四：分治<br>
### 19.删除链表的倒数第N个节点
**题解：** 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>
解法一：两次遍历法<br>
解法二：双指针一次遍历<br>
解法三：列表作弊法。<br>
### 24.两两交换链表中的节点
**题解：** 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>
解法一：列表法 一个列表存单数，一个列表存偶数，然后连起来。<br>
解法二：递归。<br>
解法三：直接翻转（栈思想）。
### 25.K个一组反转链表
**题解：** 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>
解法一：用栈，把K个数压入栈中，然后弹出来的顺序就是翻转的。<br>
解法二：尾插法，一个指针移动到要翻转部分的最后一个元素（tail）,从要翻转的第一个元素一次翻转<br>
解法三：递归。
### 61.旋转链表
**题解：** 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。主要优化k大于链表长度的情况。
### 62.不同路径
**题解：** 一个机器人位于一个 m x n 网格的左上角。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？<br>
解法一：动态规划 时间复杂度O(mn),空间复杂度可优化至O(n)<br>
解法二：排列组合(比较简单)<br>
### 63.不同路近2
**题解：** 现在考虑网格中有障碍物。网格中的障碍物和空位置分别用 1 和 0 来表示。使用动态规划，遇到1跳过并且置0，时间复杂度O(mn),空间复杂度O(1)
### 64.最小路径和
**题解：** 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>
依然动态规划，grid[i][j] += min(grid[i][j-1], grid[i-1][j])，第一行与第一列单独算。时间复杂度O(mn),空间复杂度O(1)。
## day3
### 3.无重复字符的最长子串
**题解：** 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br>
解法一：滑动窗口法，起始点固定，终点滑动，遍历每个点。<br>
解法二：双边滑动法，起始点与重点均滑动。
### 4.寻找两个有序数组的中位数
**题解：** 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。<br>
中位数将数组划为两个长度相等的部分，其中一个部分的元素总大于另一个元素。nums1和nums2的左边部分最大值都应小于nums1、nums2右边部分最小值，根据这个标准使用二分查找。
### 5.最长回文子串
**题解：** 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br>
解法一:最长公共子串，s与s的翻转字符串的最长公共子串，还必须满足下标条件。
解法二：动态规划，初始化一、二字母回文，然后找到所有三字母回文，以此类推。时间复杂度O(n^2),空间复杂度O(n^2)。<br>
解法三：中心扩展，2n-1个中心逐个扩展。时间复杂度O(n^2),空间复杂度O(1)。<br>
解法四：Manacher算法，字符之间和前后加同一字符（字符串里没有的），不用考虑偶数长度回文字符串情况。<br>
### 6.Z字形变换
**题解：** 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br>
按行排序，将对应字符放入对应行即可。
### 7.整数翻转
**题解：** 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>
使用数学方法实现弹出数字与推入数字。
### 8.字符串转换整数
**题解：** 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。<br>
### 9.回文数
**题解：** 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br>
解法一：如果非负反转判断是否相等。<br>
解法二：左右同时往之间移动比较是否相等。
### 10.正则表达式匹配
**题解：** 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '\*'的正则表达式匹配。<br>
解法一：回溯<br>
解法二：动态规划
### 11.盛最多水的容器
**题解：** 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>
两头双指针，短的一边向中心移动，当长边变短边计算面积。
### 12.整数转罗马数字
**题解：** 从大到小每一位数字顺序判断， 等于9进入下个循环，大于4小于9减5继续此循环，等于4，小于4。
## day4
### 13.罗马数字转整数
**题解：** 构建一个字典记录所罗马数字子串，遍历整个s判断当前位置和后一个位置组成的字符串是否在字典内，如果在就记录值，不在则直接记录当前字符的值。
### 17.电话号码的字母组合
**题解：** 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>
递归：递归过程中记录组合<br>
迭代：从头取出字符串，加上当前数字对应的几个字符从队尾进入。 
### 20.有效的括号
**题解：** 小、中、大括号的左边对应数字1、2、3，右边对应-1、-2、-3，指针顺序遍历。定义一个栈。遇到左括号(数字大于0)，进栈该数字，遇到右括号，等于栈顶相反数，出栈，否则无效。最后栈中物元素，则返回True。否则返回False。
### 22.括号生成
**题解：** 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。<br>
解法一：动态规划?，初始化列表['(']与[(1,n-1)],元组第一个数代表这个字符串有1个多余的左括号，第二个数字代表还可以放置n-1个左括号。顺序取出所列表里的所有字符串，如果还可以放置左括号(元组第二个数字大于0)，放置左括号加入列表；如果左括号多余右括号(元组第一个数子大于0)，放置右括号加入列表。<br>
解法二：递归，'('+i组括号+')'+n-1-i组括号,i的范围是0到n。
### 26.删除排序数组中的重复项
**题解：** 双指针，第一个指针固定，第二个指针往后寻找不相等的数放在第一个指针后面，然后第一个指针移动一个，第二个指针继续移动到尾部。
### 27.移除元素
**题解：** 双指正，一头一尾，头找等于val的值，尾找不等于val的值，将尾指针的值付给头针。
### 28.实现strStr()
**题解：** 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。遍历haystack中的所有needle长度的字符串。
### 29.两数相除
**题解：** 直观解法，被除数不断减去除数，直到被除数小于除数，符号额外处理。但是当商比较大时，循环次数过多。<br>
加速方法：减数每一次循环增加一个除数，当除数大于被除数，减数重新等于除数。
再加速：减速每一次循环左移一位，变为2倍。
### 30.串联所有单词的子串
**题解：** 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。<br>
解法一：逐一判断s中对应长度的子串是否满足要求。<br>
解法二：速度优化，每次移动一个单词，移动到尾部之后，再移动一个字符。<br>
### 31.下一个排列
**题解：** 从右边找到第一对两个连续的数字满足a[i]>a[i-1],将i-1右侧大于a[i-1]的最小数字与a[i-1]交换
## day5
### 32.最长有括号
**题解：** 
### 34.在排序数组中查找元素的第一个和最后一个位置
**题解：** 
### 35.搜索插入位置
**题解：**  
### 36.有效的数独
**题解：** 
### 37.解数独
**题解：** 
### 38.报数
**题解：** 
### 39.组合总数
**题解：**
### 40.组合总数II
**题解：** 
### 41.缺失的第一个正数
**题解：** 
### 42.接雨水
